b<-4:6
a+b
a*b
a/b
#Também pode usar números inteiros pra fazer operações com os vetores:
a+1
a*2
1/a
#Se voce fizer operações com vetores de tamanhos diferente, o R pode fazer a conta, mas vai devolvar uma mensagem de alerta junto
a*1:2
#Se os vetores forem múltiplos, entretanto, tudo certo.
a*1:6
1:2*1:4
#B.3.3 Extraction and missing values
#Pra extrair pedaços do vetor é só chamar o seu nome e usar as coordenadas entre colchetes:
Y[1]
Y[1:3]
Y>mean(Y)
Y[Y>mean(Y)]
#O R vai sempre se recusar até o fim a realizar calculos com planilhas/vetores com dados ausentes.
#Pra verificar se seu conunto de dados está ok e não falta nenhum dado, usar a função 'is.na':
a<-c(5,3,6,NA)
a
is.na(a)
!is.na(a) #a '!' significa uma negativa, ou seja: não é na!
#Pra obter a lista do que não é na:
a[!is.na(a)]
na.exclude(a) #comando que exclui os dados ausentes
#Para fazer contas com seus dados removendo os NA na mesma função:
mean(a)
mean(a, na.rm=TRUE)
d<-na.exclude(a) #aqui vc criou um novo vetor sem o NA antes de calc a média, o contrario do comando anterior
mean(d)
#B.3.4 Matrices
#Criando a matriz:
matrix(letters[1:4],ncol=2) #letters indica a categoria do dado e a sequencia que vc quer vem []; ncol= n de colunas
matrix(1:4,ncol=2) #ou
M<-matrix(1:4,nrow=2) #nrow= n de linhas, obviamente
M
#Pra que os dados do conjunto sejam inseridos no sentido das linhas e não das colunas, como é o default:
M2<-matrix(1:4,nrow=2,byrow=TRUE) #o comando aqui é byrow
M2
#Para construir uma matriz identidade:
I<-diag(1,nrow=2)
I #ela é basicamente o escalar 1 das matrizes, ou seja: bastante util.
#O resultado de uma M * M-1 (o seu inverso) é sempre uma matriz identidade de igual n de linhas e colunas
Minv<-solve(M) #Minv= matriz inversa
M %*% Minv
#Para extrair dados de uma matriz, se faz a mesma coisa dos vetores, só que se especifica a posição do valor de acordo c a linha e a coluna
M[1,2] #[linha, col]
M[1,1:2]
M[,2] #se deixar alguma das coord em branco, o R recupera uma linha ou coluna completa
#B.3.6 Lists
#As listas são só conjuntos de dados organizados juntos em ordem, que podem ser de naturezas completamente diferentes
my.list<-list(My.Y=Y,b=b,Names,Weed.data=dat,My.matrix=M2,my.no=4)
my.list
my.list[["b"]]
my.list[["2"]]
my.list[[2]]
my.list$b
my.list[1:2]
my.list[["b"]][1]
my.list$b[1]
mean(dat$height)
help(mean)
mean(1:4)
mean(1:4,trim=0)
mean(1:4,trim=0.5)
View(dat)
mean(1:4,trim=4)
class(1:10)
class(warpbreaks)
print(warpbreaks)
summary(1:10)
summary(warpbreaks)
summary(lm(breaks~wool,data=warpbreaks))
?lm
MyBogusMean<-function(x,cheat=0.05){
MyBogusMean<-function(x,cheat=0.05){
SumOfX<-Sum(x)
n<-lenght(x)
trueMean<-SumOfX/n
(1+cheat)*trueMean}
RealSales<-c(100,200,300)
MyBogusMean(RealSales)
}
MyBogusMean<-function(x,cheat=0.05){
SumOfX<-Sum(x)
n<-lenght(x)
trueMean<-SumOfX/n
(1+cheat)*trueMean
}
RealSales<-c(100,200,300)
MyBogusMean(RealSales)
MyBogusMean<-function(x,cheat=0.05){
SumOfX<-sum(x)
n<-lenght(x)
trueMean<-SumOfX/n
(1+cheat)*trueMean
}
RealSales<-c(100,200,300)
MyBogusMean(RealSales)
MyBogusMean<-function(x,cheat=0.05){
SumOfX<-sum(x)
n<-length(x)
trueMean<-SumOfX/n
(1+cheat)*trueMean
}
RealSales<-c(100,200,300)
MyBogusMean(RealSales)
MyBogusMean(RealSales,cheat=0.1)
MyBogusMean(RealSales,cheat=0)
e<-c(2,4,6,1,5,3)
e
sort(e)
sort(e,decreasing=TRUE)
e
order(e)
order(e)
order[order(e)]
e[order(e)]
dat
order.nos<-order(data$height)
order.nos<-order(dat$height)
order.nos
?order.nos
dat[order.nos,]
dat[rev(order.nos),]
m<-matrix(1:10, nrow=2)
m
#pra aplicar as acoes na matriz, voce precisa especificar os dados. Pra isso, precisa indicar
#o objeto, a margem (1 pra linhas, 2 pra colunas) e a 'ação' ou 'comando'. Assim:
apply(m,MARGIN=1,mean)
apply(m,MARGIN=2,mean)
apply(m,MARGIN=2,sum)
?rowMeans
colSums(m,1,2,na.rm=FALSE)
colSums(m,2,5,na.rm=FALSE)
lapply(m,MARGIN=2,mean)
lapply(m,MARGIN=1,mean)
lapply(m,1,2)
lapply(m,1,2, mean)
sapply(1:10,function(i)mean(rnorm(5)))
#B.6.2 Dependent iterations
#Esse e o tipo de comando usado pra dados que tem dependencia temporal.
#Ou seja: o resultado de um dos calculos vai interferir no resultado dos calculos posteriores. Assim:
gens<-10 #o numero de vezes que ele deve gerar os resultados--output
output<-numeric(gens+1) #o resultado deve ser um dado numerico equiv ao resultado da geracao anterior +1 (momento no tempo, nao +1 unidade)
output[1]<-25 #aqui ele determina o valor do seu objeto no momento inicial=gener 1
for (t in 1:gens)output[t+1]<-output[t]+round(rnorm(n=1,mean=0,sd=2),0) #aqui éa funcao propriamente dita, determinando que os dados da geracoes seguintes devem ser dependentes da anterior
#e que devem ser calculados assumindo uma distribuicao normal dos valores, com media de 0, ja que ela vai ser o resultado de desvio padrao de 2
gens<-10 #o numero de vezes que ele deve gerar os resultados--output
output<-numeric(gens+1) #o resultado deve ser um dado numerico equiv ao resultado da geracao anterior +1 (momento no tempo, nao +1 unidade)
gens<-10
output<-numeric(gens+1)
output[1]<-25
for (t in 1:gens)output[t+1]<-output[t]+round(rnorm(n=1,mean=0,sd=2),0)
output
data(trees)
attach(trees)
plot(Girth,Height)
#B.13 Graphics
#B.13.1 plot
data(trees)
attach(trees)
plot(Girth,Height)
#B.13.2 Adding points, lines and text to a plot
par(mar=c(5,4,3,2))
plot(Girth,Volume,type="n",main= "My Trees")
points(Girth, Volume, type="h",col="lightgrey")
points(Girth, Volume, type="h",col="lightgrey",pch=19)
plot
points(Girth, Volume, type="h",col="lightgrey",pch=19)
par(mar=c(5,4,3,2))
plot(Girth,Volume,type="n",main= "My Trees") #aqui ele da os eixos, indica o tipo de variavel do grafico
#e o titulo dele
points(Girth, Volume, type="h",col="lightgrey",pch=19)
htc<-(Height-min(Height))/max(Height-min(Height))
my.colors<-hcl(h=30+270*hts,alpha=0.9) #hcl= é um tipo de coloracao que facilita a percepcao humana
#hts=heights;30+270 é o intervalo de variacao dos tons das cores, que vai variar em funcao das alturas;
#esse 'alpha=0.09' é determina que pontos sobrepostos fiquem até 10% transparentes
text(Girth, Volume, Height, col=my.colors,cex=0.5+hts)#aqui ele da o comando pra aplicar a configuracao das
#cores na figura e determina que o tamanho dos simbolos pode variar 0.5de acordo com a altura da arvore
#B.13 Graphics
#B.13.1 plot
data(trees)
attach(trees)
plot(Girth,Height)
#B.13.2 Adding points, lines and text to a plot
par(mar=c(5,4,3,2))
plot(Girth,Volume,type="n",main= "My Trees") #aqui ele da os eixos, indica o tipo de variavel do grafico
#e o titulo dele
points(Girth, Volume, type="h",col="lightgrey",pch=19) #aqui ele adiciona o tipo de grafico q quer colocar
#dentro do plot e a cor
#pra adicionar pontos dentro do gráfico
hts<-(Height-min(Height))/max(Height-min(Height))
my.colors<-hcl(h=30+270*hts,alpha=0.9) #hcl= é um tipo de coloracao que facilita a percepcao humana
#hts=heights;30+270 é o intervalo de variacao dos tons das cores, que vai variar em funcao das alturas;
#esse 'alpha=0.09' é determina que pontos sobrepostos fiquem até 10% transparentes
text(Girth, Volume, Height, col=my.colors,cex=0.5+hts)#aqui ele da o comando pra aplicar a configuracao das
#cores na figura e determina que o tamanho dos simbolos pode variar 0.5de acordo com a altura da arvore
trees.sort<-trees[order(trees$Girth,trees$Height),]
text(18,40,"Volume",col="darkred")
tet(10,58,"Height")
text(18,40,"Volume",col="darkred")
text(10,58,"Height")
trees.sort<-trees[order(trees$Girth,trees$Height),]
text(18,40,"Volume",col="darkred")
text(10,58,"Height")
#B.13 Graphics
#B.13.1 plot
data(trees)
attach(trees)
plot(Girth,Height)
#B.13.2 Adding points, lines and text to a plot
par(mar=c(5,4,3,2))
plot(Girth,Volume,type="n",main= "My Trees") #aqui ele da os eixos, indica o tipo de variavel do grafico
#e o titulo dele
points(Girth, Volume, type="h",col="lightgrey",pch=19) #aqui ele adiciona o tipo de grafico q quer colocar
#dentro do plot e a cor
#pra adicionar pontos dentro do gráfico
hts<-(Height-min(Height))/max(Height-min(Height))
my.colors<-hcl(h=30+270*hts,alpha=0.9) #hcl= é um tipo de coloracao que facilita a percepcao humana
#hts=heights;30+270 é o intervalo de variacao dos tons das cores, que vai variar em funcao das alturas;
#esse 'alpha=0.09' é determina que pontos sobrepostos fiquem até 10% transparentes
text(Girth, Volume, Height, col=my.colors,cex=0.5+hts)#aqui ele da o comando pra aplicar a configuracao das
#cores na figura e determina que o tamanho dos simbolos pode variar 0.5de acordo com a altura da arvore
trees.sort<-trees[order(trees$Girth,trees$Height),]
text(18,40,"Volume",col="darkred")
text(10,58,"Height")
q()
#B.13 Graphics
#B.13.1 plot
data(trees)
attach(trees)
plot(Girth,Height)
#B.13.2 Adding points, lines and text to a plot
par(mar=c(5,4,3,2))
plot(Girth,Volume,type="n",main= "My Trees") #aqui ele da os eixos, indica o tipo de variavel do grafico
#e o titulo dele
points(Girth, Volume, type="h",col="lightgrey",pch=19) #aqui ele adiciona o tipo de grafico q quer colocar
#dentro do plot e a cor
#pra adicionar pontos dentro do gráfico
hts<-(Height-min(Height))/max(Height-min(Height))
my.colors<-hcl(h=30+270*hts,alpha=0.9) #hcl= é um tipo de coloracao que facilita a percepcao humana
#hts=heights;30+270 é o intervalo de variacao dos tons das cores, que vai variar em funcao das alturas;
#esse 'alpha=0.09' é determina que pontos sobrepostos fiquem até 10% transparentes
text(Girth, Volume, Height, col=my.colors,cex=0.5+hts)#aqui ele da o comando pra aplicar a configuracao das
#cores na figura e determina que o tamanho dos simbolos pode variar 0.5de acordo com a altura da arvore
trees.sort<-trees[order(trees$Girth,trees$Height),]
matplot(trees.sort$Girth,trees.sort[,2:3],type="b")
text(18,40,"Volume",col="darkred")
text(10,58,"Height")
quartz(,4,4)
par(mar=c(5,4,2,4))
plot(Girth, Volume,main="My Trees")
par(new=TRUE)
plot(Girth,Height,axes=FALSE,bty="n",xlab="",ylab="",pch=3)
axis(4)
mtext("Height",side=4,line=3)
par(mar=c(5,4,2,4))
plot(Girth, Volume,main="My Trees")
par(new=TRUE)
plot(Girth,Height,axes=FALSE,bty="n",xlab="",ylab="",pch=3)
axis(4)
mtext("Height",side=4,line=3)
windows(width = 5,lenght = 3)
windows(width = 5,length = 3)
windows(width = 5,height = 3)
windows(,5,5)
layout(matrix(c(1,2,3,3),nrow=2,byrow=TRUE))
plot(Girth, Height)
par(mar=c(3,3,1,1),mgp=c(1.6,0.2,0),tcl=0.2)
plot(Girth, Height,axes=FALSE,xlim=(c(8,22)))
axis(1,tcl=-0.3)
axis(2,thick=F)
rug(Height,side=2,col=2)
title("A Third,Very Wide,Plot'")
windows(,5,5)
layout(matrix(c(1,2,3,3),nrow=2,byrow=TRUE))
plot(Girth, Height)
par(mar=c(3,3,1,1),mgp=c(1.6,0.2,0),tcl=0.2)
plot(Girth, Height,axes=FALSE,xlim=(c(8,22)))
axis(1,tcl=-0.3)
axis(2,tick=F)
rug(Height,side=2,col=2)
title("A Third,Very Wide,Plot'")
windows(width = 5,height = 3)#essa funcao vai abrir um grafico com as dimensoes que vc especificou no R
windows(,5,5)
layout(matrix(c(1,2,3,3),nrow=2,byrow=TRUE))
plot(Girth, Height)
par(mar=c(3,3,1,1),mgp=c(1.6,0.2,0),tcl=0.2)
plot(Girth, Height,axes=FALSE,xlim=(c(8,22)))
axis(1,tcl=-0.3)
axis(2,tick=F)
rug(Height,side=2,col=2)
title("A Third,Very Wide,Plot")
windows(,4,4)
par(mar=c(5,4,2,4))
plot(Girth, Volume,main="My Trees") #Ate aqui eu so plotei um grafico de pontos normal
#Aqui vem o truque!
par(new=TRUE)
plot(Girth,Height,axes=FALSE,bty="n",xlab="",ylab="",pch=3)
axis(4)
mtext("Height",side=4,line=3)
par(mar=c(5,4,2,4))
plot(Girth, Volume,main="My Trees")
par(new=TRUE)
plot(Girth,Height,axes=FALSE,bty="n",xlab="",ylab="",pch=3)
axis(4)
mtext("Height",side=4,line=3)
#B13.4 Controlling graphics devices
windows(width = 5,height = 3)#essa funcao vai abrir um grafico com as dimensoes que vc especificou no R
windows(,5,5)
layout(matrix(c(1,2,3,3),nrow=2,byrow=TRUE))
plot(Girth, Height)
par(mar=c(3,3,1,1),mgp=c(1.6,0.2,0),tcl=0.2)
plot(Girth, Height,axes=FALSE,xlim=(c(8,22)))
axis(1,tcl=-0.3)
axis(2,tick=F)
rug(Height,side=2,col=2)
title("A Third,Very Wide,Plot")
windows(width = 5,height = 3)#essa funcao vai abrir um grafico com as dimensoes que vc especificou no R
windows(,5,3)#essa funcao vai abrir um grafico com as dimensoes que vc especificou no R
windows(width = 5,height = 3)#essa funcao vai abrir um grafico com as dimensoes que vc especificou no R
windows(,5,5)
layout(matrix(c(1,2,3,3),nrow=2,byrow=TRUE))
plot(Girth, Height)
par(mar=c(3,3,1,1),mgp=c(1.6,0.2,0),tcl=0.2)
plot(Girth, Height,axes=FALSE,xlim=(c(8,22)))
axis(1,tcl=-0.3)
axis(2,tick=F)
rug(Height,side=2,col=2)
title("A Third,Very Wide,Plot")
getwd()
windows(,4,4)
plot(Height,Volume,main="Tree Data")
dev.print(pdf,"My Tree.pdf")
#B.3- Data Structures
#B.3.1 Vectors
Y<-c(8.3,8.6,10.7,10.8,11,11,11.1,11.2,11.3,11.4)
Y=c(8.3,8.6,10.7,10.8,11,11,11.1,11.2,11.3,11.4)
#Para montar sequências, usar um dos comandos:
1:4
4:1
-1:3
-(1:3)
#Para especificar os intervalos da sequencia:
seq(from=1, to=3, by=0.2)
seq(1,3, by=0.2)
seq(1,3,length=7)
seq(1,3,0.2)
#Para sequencias repetitivas se usa a função:
rep(1,3)
rep(1:3,2)
rep(1:3,each=2)
#B.3.2 Getting information about vectors
#soma
sum(Y)
#média
mean(Y)
#máximo
max(Y)
#tamanho amostral
length(Y)
#Visão geral
summary(Y)
#Obviamente, vetores também podem ser nomes,categorias,tratamentos etc:
Names<-c("Sarah","Yunluan")
Names
b<-c("TRUE","FALSE")
b
#O R pode ajudar a reconhecer a classe do seu vetor, caso você não consiga sozinho:
class(Y)
class(b)
#Para testar afirmações:
Y>10
Y>mean(Y)
Y==11
Y!=11
#Igual ==, Diferente !=
#Algebra with vectors
a<-1:3
b<-4:6
a+b
a*b
a/b
#Também pode usar números inteiros pra fazer operações com os vetores:
a+1
a*2
1/a
#Se voce fizer operações com vetores de tamanhos diferente, o R pode fazer a conta, mas vai devolvar uma mensagem de alerta junto
a*1:2
#Se os vetores forem múltiplos, entretanto, tudo certo.
a*1:6
1:2*1:4
#B.3.3 Extraction and missing values
#Pra extrair pedaços do vetor é só chamar o seu nome e usar as coordenadas entre colchetes:
Y[1]
Y[1:3]
Y>mean(Y)
Y[Y>mean(Y)]
#O R vai sempre se recusar até o fim a realizar calculos com planilhas/vetores com dados ausentes.
#Pra verificar se seu conunto de dados está ok e não falta nenhum dado, usar a função 'is.na':
a<-c(5,3,6,NA)
a
is.na(a)
!is.na(a) #a '!' significa uma negativa, ou seja: não é na!
#Pra obter a lista do que não é na:
a[!is.na(a)]
na.exclude(a) #comando que exclui os dados ausentes
#Para fazer contas com seus dados removendo os NA na mesma função:
mean(a)
mean(a, na.rm=TRUE)
d<-na.exclude(a) #aqui vc criou um novo vetor sem o NA antes de calc a média, o contrario do comando anterior
mean(d)
#B.3.4 Matrices
#Criando a matriz:
matrix(letters[1:4],ncol=2) #letters indica a categoria do dado e a sequencia que vc quer vem []; ncol= n de colunas
matrix(1:4,ncol=2) #ou
M<-matrix(1:4,nrow=2) #nrow= n de linhas, obviamente
M
#Pra que os dados do conjunto sejam inseridos no sentido das linhas e não das colunas, como é o default:
M2<-matrix(1:4,nrow=2,byrow=TRUE) #o comando aqui é byrow
M2
#Para construir uma matriz identidade:
I<-diag(1,nrow=2)
I #ela é basicamente o escalar 1 das matrizes, ou seja: bastante util.
#O resultado de uma M * M-1 (o seu inverso) é sempre uma matriz identidade de igual n de linhas e colunas
Minv<-solve(M) #Minv= matriz inversa
M %*% Minv
#Para extrair dados de uma matriz, se faz a mesma coisa dos vetores, só que se especifica a posição do valor de acordo c a linha e a coluna
M[1,2] #[linha, col]
M[1,1:2]
M[,2] #se deixar alguma das coord em branco, o R recupera uma linha ou coluna completa
#B3.5 Data frames
dat<-data.frame (species=c("S. altissima","S. rugosa","E. graminifolia","A. pilosus"),treatment=factor(c("Control","Water","Control","Water")),height=c(1.1,0.8,0.9,1),width=c(1,1.7,0.6,0.2))
dat
#Para extrair dados da planilha se usa os mesmos comandos das matrizes
dat[,2]
dat[2,]
dat[3,4]
dat[,2]=="Water" #pode usar os mesmos testes de matrizes aqui tamb�m!
dat[dat[,2]=="Water",] #aqui ele montou uma nova planilha usando os dados da planilha original que Tinham o tratamento Water na coluna 2!
#a funcao 'subset' faz o mesmo papel:
subset(dat, treatment=="Water")
#Factors
c("Control", "Medium", "High") #criando o fator- nesse caso, com 3 n�veis
rep(c("Control", "Medium", "High"), each=3)
Treatment<-factor(rep(c("Control", "Medium", "High"), each=3))
Treatment #l� nos scrip, o R areorganizou os dados em ordem alfab�tica... Pra corrigir:
levels(Treatment)
stripchart(1:9~Treatment)
Treatment<-factor(rep(c("Control", "Medium", "High"), each=3),levels=c("Control", "Medium", "High"))
levels(Treatment) #Esse comando reorganiza a ordem dos seus n�veis!!!
stripchart(1:9~Treatment)
#B.3.6 Lists
#As listas sao so conjuntos de dados organizados juntos em ordem, que podem ser de naturezas completamente diferentes
my.list<-list(My.Y=Y,b=b,Names,Weed.data=dat,My.matrix=M2,my.no=4)
my.list
my.list[["b"]] #or
my.list$b
my.list[[2]] #quando chamar item pelo numero, nao usa "", esse se usa quandofor chamar por nomes!
my.list[1:2] #quando voce usa so um [] voce pode chamar mais de um item e n�o usa ""
#Pra extrair apenas um item ou alguns items de um componente da lista:
my.list[["b"]][1] #or
my.list$b[1]
#B.1- Help
#Para buscar info na web sobre qualquer função/comando:
?(mean)
#ou
help("mean")
#Para que ele páre de abrir o browser com esse comando:
options(htmlhelp=FALSE)
help("mean")
#Para buscar ajuda sobre uma função que você não sabe exatamente o nome:
help.search("mean")
#E caso queira a info direto no R, usa:
apropos("mean")
#Caso você estea em busca de info sobre algum pacote do R, usa esse comando:
RSiteSearch("violin")
#E pra refinar a buscar por algum subitem específico, usa o argumento 'restrict=c(x)', assim:
RSiteSearch("violin",restrict=c("functions"))
#Para pesquisar mais sobre o RSiteSearch, usa:
help(RSiteSearch)
q()
#B.1- Help
#Para buscar info na web sobre qualquer função/comando:
?(mean)
#ou
help("mean")
#Para que ele páre de abrir o browser com esse comando:
options(htmlhelp=FALSE)
help("mean")
#Para buscar ajuda sobre uma função que você não sabe exatamente o nome:
help.search("mean")
#E caso queira a info direto no R, usa:
apropos("mean")
#Caso você estea em busca de info sobre algum pacote do R, usa esse comando:
RSiteSearch("violin")
#E pra refinar a buscar por algum subitem específico, usa o argumento 'restrict=c(x)', assim:
RSiteSearch("violin",restrict=c("functions"))
#Para pesquisar mais sobre o RSiteSearch, usa:
help(RSiteSearch)
#B.2-Assignment
#Como criar o seu vetor-- dar nome aos bois:
a<-2+3
a
b<-a+a
a+a;a+b
#ou seja, você pode executar mais de uma acoo na mesma linha, e só usar o ;
q()
